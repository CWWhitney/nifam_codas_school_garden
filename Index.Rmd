---
title: "School gardens in urban Hanoi"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(gtExtras)
library(svglite)
```

Here we model an intervention to address malnutrition among school-aged children in urban Hanoi. The model was developed across several iterative workshops in July 2023. These included decision definition, conceptual model development of the selected decision and an initial programming session with preliminary model results. The resulting model was further developed through August to November 2023. A test run of the intervention will be carried out by the Center for the Development of Organic Agriculture (CODAS) under the Association of Organic Agriculture of Vietnam.

![](figures/outline.png)

# Should urban Hanoi school boards invest time and money in creating school gardens? Should they invest in formal STEM education as part of these gardens?

The gardens will be existing areas on school grounds. The STEM option gardens will be designed to for teaching about nutrition and STEM (an approach to learning and development that integrates science, technology, engineering and maths) at primary and secondary schools. In the 2nd year the garden is expected to start running well. The 3rd year is when the STEM education plan will be fully running.

## Methods

We use several different functions to create a working model of the garden intervention.

### Chance Event Function: Generating Conditional Values

The `chance_event` function generates conditional values with:

$$
   occurrence =
   \begin{cases}
   rbinom(length(value\_if), 1, chance) & if  !one\_draw \\
   rbinom(1, 1, chance) & if  one\_draw
   \end{cases}
   $$

and final values with:

$$
   chance\_event = occurrence \cdot value\_if + (1 - occurrence) \cdot value\_if\_not
   $$

### Value Varier Function: Generating Synthetic Data

```{r vv}
source("functions/vv.R")
```

The `vv` function generates synthetic data with varying means and coefficients of variation with:

-   $n$: Number of data points to generate.
-   $var\_mean$: Mean value for the data.
-   $var\_CV$: Coefficient of Variation (CV) for the data.
-   $distribution$: Distribution of the data (e.g., normal distribution).
-   $absolute\_trend$: Absolute trend to add to the data.
-   $relative\_trend$: Relative trend to apply to the data.
-   $lower\_limit$: Lower limit for generated data.
-   $upper\_limit$: Upper limit for generated data.

These are used to calculate annual means:

-   If both absolute and relative trends are absent, the annual means remain constant:

    $$
    annual\_means = var\_mean
    $$

-   If an absolute trend is present, annual means are adjusted linearly:

    $$
    annual\_means = var\_mean + absolute\_trend \cdot (0, 1, \ldots, n-1)
    $$

-   If only a relative trend is present, annual means change multiplicatively:

    $$
    annual\_means = var\_mean \cdot (1 + relative\_trend / 100)^{(0, 1, \ldots, n-1)}
    $$

-   Generate random data points based on the specified distribution using calculated annual means:

    $$
    out \sim \mathcal{N}(annual\_means, \lvert annual\_means \rvert \cdot \frac{var\_CV}{100})
    $$

-   If specified, limit data points to the defined lower and upper limits:

    $$
    out = \max(out, lower\_limit), \quad out = \min(out, upper\_limit)
    $$

### Net Present Value (NPV)

```{r NPV}
source("functions/discount.R")
```

The discounted value of a time series value $x_t$ at time $t$ can be calculated using the formula:

$$
   \text{Discounted Value}_t = \frac{x_t}{\left(1 + \frac{\text{Discount Rate}}{100}\right)^{t-1}}
   $$

Where:

-   $x_t$ is the value at time $t$,

-   $\text{Discount Rate}$ is the discount rate provided to the function,

-   $t$ is the time period (starting from 1).

2.  **Net Present Value (NPV)** (if `calculate_NPV` is set to `TRUE`): The Net Present Value of a time series with discounted values can be calculated as the sum of all discounted values:

    $$
    \text{NPV} = \sum_{t=1}^{n} \frac{x_t}{\left(1 + \frac{\text{Discount Rate}}{100}\right)^{t-1}}
    $$

    Where $n$ is the number of time periods in the time series.

## Monte Carlo Simulation Function

```{r MC}
source("functions/mcSimulation.R")
```

We use the `mcSimulation` function to perform Monte Carlo simulations to estimate model outputs based on provided parameters and a model function.

## Monte Carlo Simulation Process

The Monte Carlo simulation process generates a set of estimated model outputs based on random input samples, providing a distribution of potential outcomes including:

-   random input generation with $x_1, x_2, \ldots, x_n$ as a set of $n$ random input samples drawn from a given distribution, representing the input parameters of the model.

-   a model function $f(x)$ that maps the input data $x$ to the corresponding model output $y$. This can be expressed as:

    $$
     y_i = f(x_i), \quad i = 1, 2, \ldots, n
     $$

-   Estimated model outputs $\hat{y}_1, \hat{y}_2, \ldots, \hat{y}_n$ obtained by applying the model function to the random input samples:

    $$
     \hat{y}_i = f(x_i), \quad i = 1, 2, \ldots, n
     $$

# Urban Hanoi school garden simulation

```{r mcsimulation}
# Source our model
source("CODAS_Garden_Model.R")

# Ensure consistent results with the random number generator
# not for each 'run' of the MC simulation but for 
# consistency each time we call on the simulation 
set.seed(1234) 

garden_simulation_results <- mcSimulation(
  estimate = estimate_read_csv("inputs_school_garden.csv"),
  model_function = school_garden_function,
  numberOfModelRuns = 1000, #run 1000 times
  functionSyntax = "plainNames"
)

```

The way we present NPV values can influence decision makers. The same information presented in different ways can even lead to different decisions. Here we derive a plot that compares the decision options as pure NPV values.

```{r}
source("functions/plot_distributions.R")
plot_distributions(mcSimulation_object = garden_simulation_results, 
                                    vars = c("NPV_garden","NPV_garden_STEM", "NPV_no_garden"),
                                    method = 'hist_simple_overlay', 
                                    base_size = 7, 
                                    x_axis_name = "Comparative NPV outcomes")
```

## Framing the outcomes

Under Prospect Theory the way we present NPV values can influence decision makers - the same information presented in different ways can lead to different decisions. For example, framing a projected NPV gain as a "reduction in potential loss" might make it more attractive to decision makers due to loss aversion.

Here we plot the distribution for the decision and frame the projected NPV gain for the 'decision' (distributions for the two options with the NPV values of the `no garden` option subtracted from those for the `garden`). If we display this as a "Reduction in potential loss" it might be more attractive to decision makers due to loss aversion, i.e. school boards might put more emphasis on avoiding potential losses than on seeking gains. We can frame our results as a strategy that minimizes losses rather than one that maximizes gains.

```{r framing_NPV_results}
plot_distributions(mcSimulation_object = garden_simulation_results, 
                                    vars = c("decision", "decision_STEM"),
                                    method = 'hist_simple_overlay', 
                                    base_size = 7,  
                                    x_axis_name = "Reduction in potential loss")

```

## Summary of results for the decision

## Summary

Summary of the garden intervention options with gt_plt_summary() from {gtExtras} and with options from {svglite}. 

```{r gtExtras_summary}
# Subset the outputs from the mcSimulation function (y) to summarize only on the variables that we want.
# names(garden_simulation_results$x)
mcSimulation_summary <- data.frame(garden_simulation_results$x[2:61],
 # names(garden_simulation_results$x)
                                 garden_simulation_results$y[1:7])

gt_plt_summary(mcSimulation_summary) 
```

Summary of the savings for the passive education garden option

```{r summary_decision}
summary(garden_simulation_results$y$decision)
```

Summary of the savings for the formal STEM education garden option

```{r summary_decision_stem}
summary(garden_simulation_results$y$decision_STEM)
```


Summary of costs

```{r summary_costs}
summary(garden_simulation_results$y$total_costs)
```

```{r summary_costs_stem}
summary(garden_simulation_results$y$total_costs_STEM)
```

# First year

```{r summary_first_year_costs}
summary(garden_simulation_results$y$Cashflow_garden1)
```

```{r summary_first_year_costs_stem}
summary(garden_simulation_results$y$Cashflow_garden_STEM1)
```
# Cashflow of the garden option without formal STEM education

```{r}
source("functions/plot_cashflow.R")
plot_cashflow(mcSimulation_object = garden_simulation_results, 
              cashflow_var_name = "Cashflow_garden")

```
Cashflow of the garden option with formal STEM education

```{r}
source("functions/plot_cashflow.R")
plot_cashflow(mcSimulation_object = garden_simulation_results, 
              cashflow_var_name = "Cashflow_garden_STEM")
```

# Expected Value of Perfect Information (EVPI)

Here we assess value of information with the `multi_EVPI` function.

```{r}
# Subset the outputs from the mcSimulation function (y) by selecting the correct variables be sure to run the multi_EVPI only on the variables that we want. Find them with names(garden_simulation_results$y)
mcSimulation_table <- data.frame(garden_simulation_results$x, 
                                 garden_simulation_results$y[1:5])
```

Value of information for the garden option (no STEM).

```{r evpi-assess-garden}
source("functions/multi_EVPI.R")
# first_out_var is the first result variable in the table, "NPV_garden" in our case.
evpi <- multi_EVPI(mc = mcSimulation_table, first_out_var = "NPV_garden")

source("functions/plot_evpi.R")
plot_evpi(evpi, decision_vars = "decision")
```
Value of information for the garden option with formal STEM education.

```{r evpi-assess-garden-stem}
# using the results of the same multi_EVPI
plot_evpi(evpi, decision_vars = "decision_STEM")
```

# PLS

We use Projection to Latent Structures model to get some sense of the correlation strength and direction for model variables and our outcome variables.

For passive education garden option

```{r}
source("functions/pls_model.R")
pls_result <- pls_model(object = garden_simulation_results,
                                resultName = names(garden_simulation_results$y)[1], # the "NPV_garden" 
                                ncomp = 1)
# read in the common input table
input_table <- read.csv("inputs_school_garden.csv")
# source the plot function
source("functions/plot_pls.R")
plot_pls(pls_result, input_table = input_table, threshold = 0.9)
```

For school garden with formal STEM education

```{r}
pls_result_STEM <- pls_model(object = garden_simulation_results,
                                resultName = names(garden_simulation_results$y)[2], # the "NPV_garden_STEM" 
                                ncomp = 1)

plot_pls(pls_result_STEM, input_table = input_table, threshold = 0.9)
```


The full repository can be accessed at https://github.com/CWWhitney/nifam_codas_school_garden with the following QR code.

<!-- The git create a qr -->
<!-- library(qrcode) -->
<!-- qrcode_gen('https://github.com/CWWhitney/kon_tum_homegardens') -->

![](figures/CODAS_School_garden_git.png)